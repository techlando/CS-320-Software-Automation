# CS-320-Software-Automation

## Reflection and Context
As I reflect on my work in Projects One and Two, I see how much I’ve grown in creating software that is both functional and secure. These projects challenged me to think critically about the details, from writing clean, maintainable code to designing tests that uncover hidden issues. Documenting my work here will not only help me revisit these skills later but also showcase my approach to solving problems for future opportunities.

## Ensuring Functionality and Security
To make sure my code and software are functional and secure, I rely on a systematic process of development and testing. In ContactTest.java and ContactServiceTest.java, I wrote unit tests that pushed my code through different scenarios, including edge cases. This gave me confidence that the features I built would work as expected. Security was always top of mind, whether it was validating inputs, handling sensitive data carefully, or following principles like least privilege in ContactService.java. These steps helped reduce vulnerabilities while keeping the program reliable.

## Interpreting User Needs
Understanding what users need and translating that into a working program is an essential part of development. In Project Two, I spent time analyzing the requirements and figuring out how to meet them through code and testing. This process meant thinking like a user—anticipating potential issues and ensuring the program could handle real-world scenarios. Breaking down requirements into clear tasks helped me stay focused and deliver a solution that aligned with the goals.

## Software Design Approach
When I design software, I take an incremental approach. I like to start small, breaking down the project into manageable pieces, and then build up from there. This method helps me stay organized and test each part thoroughly before integrating it with the rest. For example, in Contact.java and ContactService.java, I applied object-oriented principles like encapsulation to make the code modular and easier to maintain. Peer reviews and feedback were also key—they gave me fresh perspectives and helped refine my work to meet both functional and non-functional requirements.

## Conclusion
The work I completed in these projects highlights my ability to balance functionality, security, and user needs. Whether it’s writing tests to uncover bugs, designing modular and maintainable code, or focusing on user-centered development, I’ve learned how to approach software development thoughtfully. These projects are a solid representation of the skills I’ve built, and I’m excited to continue refining them as I take on new challenges.
